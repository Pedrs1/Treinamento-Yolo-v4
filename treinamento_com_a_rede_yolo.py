# -*- coding: utf-8 -*-
"""treinamento com a rede YOLO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_-H8RMQpem7DpWnxsE4jxrBUI9itSNDU

#Treinamento com a Rede YOLO.v4
"""

#Libere o acesso ao Google Drive, para salvar as ações

from google.colab import drive
drive.mount('/content/gdrive')

"""Congratulations! Now you can access to your local computer folder directly from here!

Check it out!
"""

# Commented out IPython magic to ensure Python compatibility.
#Clonagem e compilação do Darknet
!git clone https://github.com/AlexeyAB/darknet
# %cd darknet
!make

#definição de ações
data_file = "/content/darknet/cfg/coco.names"
config_file = "/content/darknet/yolov4.cfg"
weights_file = "/content/darknet/yolov4.weights"

# Commented out IPython magic to ensure Python compatibility.
#Direcione a pasta importada
# %cd /content/darknet
!ls -la

#descompactação de arquivo
!sudo apt-get install tree

# Execute o comando tree, verificando se a pasta existe antes
import os
if os.path.exists("/content/darknet"):
  !tree //content/darknet
else:
  print("O diretório /content/darknet não existe.")

#verificação da versão do CUDA instalado
!/usr/local/cuda/bin/nvcc --version

# Commented out IPython magic to ensure Python compatibility.
# Navegar até a pasta cuDNN no Google Drive (ajuste o caminho se necessário)
# %cd /content/gdrive/MyDrive/cuDNN  # Substitua 'MyDrive/cuDNN' pelo caminho correto

# Atualizar o CUDA (se necessário, substitua pelo comando correto para sua versão)
!sudo apt-get update
!sudo apt-get install cuda-toolkit-11-8 # Substitua 11-8 pela sua versão do CUDA

# Commented out IPython magic to ensure Python compatibility.
##Clonagem de Compilação de projeto Darknet

from google.colab import drive
import os
drive.mount('/content/gdrive')

# Compilação de Darknet
!git clone https://github.com/AlexeyAB/darknet
# %cd darknet
!sed -i 's/OPENCV=0/OPENCV=1/' Makefile
!sed -i 's/GPU=0/GPU=1/' Makefile
!sed -i 's/CUDNN=0/CUDNN=1/' Makefile
!make

# Navegação até o diretorio
# %cd /content/darknet
!ls -la

# Instalação (Caso não instalado)
!sudo apt-get install tree

# Check de pasta
if os.path.exists("/content/darknet"):
  !tree /content/darknet
else:
  print("The directory /content/darknet does not exist.")

# Navigate to the cuDNN Ajustes
!cp -r /content/gdrive/MyDrive/cuDNN/* /usr/local/cuda/lib64/

# Commented out IPython magic to ensure Python compatibility.
# execuções futuras
!mkdir -p /content/darknet
# %cd /content/darknet
!chmod +x ./darknet

# Commented out IPython magic to ensure Python compatibility.
#importação da imagem a ser utilizada/ converções necessarias
def imShow(path):
    import cv2
    import matplotlib.pyplot as plt
#     %matplotlib inline

    image = cv2.imread(path)
    height, width = image.shape[:2]
    resized_image = cv2.resize(image, (3*width, 3*height), interpolation=cv2.INTER_CUBIC)

    fig = plt.gcf()
    fig.set_size_inches(18, 10)
    plt.axis("off")
    plt.imshow(cv2.cvtColor(resized_image, cv2.COLOR_BGR2RGB))
    plt.show()

def upload():
    from google.colab import files
    uploaded = files.upload()
    for name, data in uploaded.items():
        with open(name, 'wb') as f:
            f.write(data)
        print('saved file', name)

def download(path):
    from google.colab import files
    files.download(path)

# Not necessary cell
# Get yolov3 weights
!wget https://github.com/AlexeyAB/darknet/releases/download/darknet_yolo_v4_pre/yolov4-csp.weights

def detect_objects(image_path):
    # Execute o Darknet usando o modelo YOLOv3 com pesos pré-treinados
    !./darknet detector test cfg/coco.data cfg/yolov4.cfg yolov4-csp.weights {image_path} -dont-show

    # Mostrar o resultado usando a função auxiliar imShow()
    imShow('predictions.jpg')

# Commented out IPython magic to ensure Python compatibility.
# clone <https://github.com/lichengunc/refer.git>

from google.colab import drive
import os
import cv2
import matplotlib.pyplot as plt
from google.colab import files

# Mount Google Drive
drive.mount('/content/gdrive')

# Clone the refer repository
!git clone https://github.com/lichengunc/refer.git

# Navigate to the cloned repository
# %cd refer

#Direcione a pasta importada
# %cd /content/darknet # This line assumes darknet is now in /content/darknet

!ls -la

#descompactação de arquivo
!sudo apt-get install tree
# Execute o comando tree, verificando se a pasta existe antes
if os.path.exists("/content/darknet"):
  !tree //content/darknet # Note: Double slashes might be a typo, use a single slash
else:
  print("O diretório /content/darknet não existe.")

# Commented out IPython magic to ensure Python compatibility.
# Montar o Google Drive
from google.colab import drive
drive.mount('/content/gdrive')

# Clonar o repositório Darknet e compilar
!git clone https://github.com/AlexeyAB/darknet
# %cd darknet
!make

# Definir o caminho para o diretório darknet
darknet_path = "/content/darknet"

# Adicionar darknet ao PATH do sistema
import os
os.environ['PATH'] += os.pathsep + darknet_path

# Verificar se o darknet está no PATH
!echo $PATH

# Caminhos para os arquivos
data_file = "/content/darknet/cfg/coco.names"
config_file = "/content/darknet/yolov4.cfg"
weights_file = "/content/darknet/yolov4.weights"

# Treinar o modelo YOLOv4
!./darknet detector train {data_file} {config_file} {weights_file}

"""Base Treinada :)"""

y_true = test_labels # Assuming test_labels are the true labels

# Calculate TP, TN, FP, FN
TP = np.zeros(10)  # True Positives for each class
TN = np.zeros(10)  # True Negatives for each class
FP = np.zeros(10)  # False Positives for each class
FN = np.zeros(10)  # False Negatives for each class

for i in range(10):
  for j in range(len(y_true)):
    if y_true[j] == i and y_pred[j] == i:
      TP[i] += 1
    elif y_true[j] != i and y_pred[j] != i:
      TN[i] += 1
    elif y_true[j] != i and y_pred[j] == i:
      FP[i] += 1
    elif y_true[j] == i and y_pred[j] != i:
      FN[i] += 1

# Calculate metrics for each class
accuracy = np.zeros(10)
sensitivity = np.zeros(10)
specificity = np.zeros(10)
precision = np.zeros(10)
f1_score = np.zeros(10)


for i in range(10):
    accuracy[i] = (TP[i] + TN[i]) / (TP[i] + TN[i] + FP[i] + FN[i]) if (TP[i] + TN[i] + FP[i] + FN[i]) > 0 else 0
    sensitivity[i] = TP[i] / (TP[i] + FN[i]) if (TP[i] + FN[i]) > 0 else 0
    specificity[i] = TN[i] / (TN[i] + FP[i]) if (TN[i] + FP[i]) > 0 else 0
    precision[i] = TP[i] / (TP[i] + FP[i]) if (TP[i] + FP[i]) > 0 else 0
    f1_score[i] = 2 * (precision[i] * sensitivity[i]) / (precision[i] + sensitivity[i]) if (precision[i] + sensitivity[i]) > 0 else 0


# Print the metrics (example for class 0)
print("Metrics for class 0")
print(f"Accuracy: {accuracy[0]*100:.4f}%")
print(f"Sensitivity (Recall): {sensitivity[0]*100:.4f}%")
print(f"Specificity: {specificity[0]*100:.4f}%")
print(f"Precisão: {precision[0]*100:.4f}%")
print(f"F1-score: {f1_score[0]*100:.4f}%")